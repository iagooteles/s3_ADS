//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Frontend => 
    UI: Telas;
    Componentes: ;
    Browser: ;

Backend =>

Servidor: Apache, Tomcat;
Banco de dados: ;
API's: ;

Arquiteturas: 

    Monolítico - Todo o software em um só ambiente/container; Se cair, der errado, falhar, tudo da errado; Só comporta uma linguagem
    Micro-serviços - Serviços/containers separados, se cair uma aplicação não necessariamente vai cair tudo; Pode comportar várias linguagens, maior flexibilicade; Mais complexo, por ter que comunicar um micro-serviço com outro; Comunicação via requisição HTTP;

Cada micro-serviço vai possuir seu próprio CRUD;
    



* multicamadas => 

__________________________________________________________________________________________________________________________

Usar o spring initializer para configuração de pacotes => https://start.spring.io/ ;
Nesse projeto usaremos Maven como gerenciador de pacotes;

Dependências: 
    Spring Boot DevTools;
    Spring Web;
    H2 => Banco de dados em memória;
    

Gerar o pom.xml e abrir ele com o intellij (já que a extensão do java pode ser baixada nos pcs da unifor);

* temurim



__________________________________________________________________________________________________________________________


backend => 
    - Regras de negócio do lado do servidor;
    -

frontend =>


MVC => Padrão de projeto;
    - Model => Regra de negócio para se conectar ao banco;
    - View => UI, Telas;
    - Controller => Lidar com as requisições das telas e processa; Regras de negócio; 

Não vamos trabalhar com MVC nesse projeto;

Vamos usar o padrão multi-camadas:

- Controller:
    Receber a requisição e chama a service para implementar a regra de negócio;
    Se Comunica com a service;
    Chamar a regra de negócio;
    Porta de entrada do backend(clase de fronteira);
        Get;
        Post;
        Put;
        Delete;
- Service:
    Regras de negócio;
    A service chama a Repository;
- Repository:
    Conexão com o banco de dados;
    Onde acontece a persistência dos dados;
- DTO:
    Data Transfer Object;
    Camada responsável por criar um objeto espelho da entidade, mas que pode ser diferente em alguns momentos;
    Serve, por exemplo, para não enviar dados sensíveis como seria se enviássemos a entidade inteira;
- Entity:
    Criação do objeto;

ORM => Mapeamento Objeto Relacional;


JPA =>

